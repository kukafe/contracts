pragma solidity ^0.6.0;

import "./ISwapPathRegistry.sol";
import "./IPanwexPair.sol";
import "./KCSRouter2.sol";
import "./Buybackstrat.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

interface IMasterChefWStakingReferral {
    
    function stake(uint256 amount) external;
    function withdraw(uint256 amount) external;

    function getReward() external;

    function balanceOf(address user) external view returns (uint256);
}
interface IVault {
    function updatePricePerShare() external;

}

/**
 * @dev Implementation of a strategy to get yields from farming LP Pools in PanwexSwap.
 * PanwexSwap is an automated market maker (“AMM”) that allows two tokens to be exchanged on the Binance Smart Chain.
 * It is fast, cheap, and allows anyone to participate. PanwexSwap is aiming to be the #1 liquidity provider on BSC.
 *
 * This strategy simply deposits whatever funds it receives from the vault into the selected MasterChef pool.
 * CAKE rewards from providing liquidity are farmed every few minutes, sold and split 50/50. 
 * The corresponding pair of assets are bought and more liquidity is added to the MasterChef pool.
 * 
 * This strat is currently compatible with all LP pools.
 */
contract StrategyLPSynthetix is Ownable, Pausable {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    /**
     * @dev Tokens Used:
     * {wkcs} - Required for liquidity routing when doing swaps.
     * {wex} - Token generated by staking our funds. In this case it's the CAKEs token.
     * {eleven} - ElevenFinance token, used to send funds to the treasury.
     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.
     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IPanwexPair tokens
     */
    modifier onlyOwnerOrVault() {
        require(owner() == _msgSender() || vault == _msgSender() , "Ownable: caller is not the owner/vault");
        _;
    }
    
    modifier onlyVault() {
        require(vault == _msgSender() , "Ownable: caller is not the vault");
        _;
    }
    modifier onlyNonContract(){
        if (CHECK_BY_ORIGIN){
            // require(!Address.isContract(tx.origin), "!contract");
            require(tx.origin == msg.sender, "!contract!");
        }else{
            require(!Address.isContract(msg.sender), "!contract");
        }
        _;
    }
    // these cant be changed after constructor
    address public lpPair;

    address public rewardToken;
    address public otherToken;
    address public baseToken;

    address public router;

    address public masterchef;

    address public vault;
    
    // these can be changed after constructor, by the vault
    address public buybackstrat;
    address public swapPathRegistry;
    uint256 public MIN_TO_LIQUIFY = 100;

    uint256 public constant FEE_CAP = 30 * 100; // max fee possible 30%
    bool public CHECK_BY_ORIGIN = true; 


    event Deposit(address indexed account, uint256 amt);
    event Withdraw(address indexed account, uint256 amt);
    event Compound(address indexed caller, uint256 lpAdded);
    event CompoundLoss(address indexed caller, uint256 change); // shouldnt happen since im comparing balanceOfPool
    
    event SetBuybackStrat(address a);
    event SetSwapPathRegistry(address a);
    event SetMinToLiquify(uint256 n);
    event SetCheckByOrigin(bool b);

    function setCheckByOrigin(bool b) external onlyOwner {
        CHECK_BY_ORIGIN = b;
        emit SetCheckByOrigin(b);
    }
    function setBuybackStrat(address _address) external onlyOwner{
        buybackstrat = _address;
    }
    function setSwapPathRegistry(address _a) external onlyOwner{
        require(_a != address(0), "no zero address!");
        swapPathRegistry = _a;
        emit SetSwapPathRegistry(_a);
    }
    function setMinToLiquify(uint256 n) external onlyOwner{
        MIN_TO_LIQUIFY = n;
        emit SetMinToLiquify(n);
    }

    function depositToFarm(uint256 amt) internal{
        IMasterChefWStakingReferral(masterchef).stake(amt);
        emit Deposit(msg.sender, amt);

    }
    function withdrawFromFarm(uint256 amt) internal {
        IMasterChefWStakingReferral(masterchef).withdraw(amt);
        emit Withdraw(msg.sender, amt);
    }
    function claim() internal {
        IMasterChefWStakingReferral(masterchef).getReward();
    }
    /**
     * @dev Initializes the strategy with the token to maximize.
     */
    constructor(address _lpPair, 
    address _rewardToken, 
    address _baseToken, // 0 when in token mode
    address _vault, 
    address _masterchef, address _router, address _swapPathRegistry, address _feeStrat) public {
        lpPair = _lpPair;
        masterchef = _masterchef;
        router = _router;
        swapPathRegistry = _swapPathRegistry;
        buybackstrat = _feeStrat;

        vault = _vault;
        
        if (_baseToken == address(0)){
            // token mode
            otherToken = address(0);
            baseToken = address(0);
        } else {
            address token0 = IPanwexPair(_lpPair).token0();
            address token1 = IPanwexPair(_lpPair).token1();
            (otherToken, baseToken) = (token0 == _baseToken) ? (token1,token0) : (token0,token1);
            IERC20(otherToken).safeApprove(router, 0);
            IERC20(otherToken).safeApprove(router, uint(-1));
            IERC20(baseToken).safeApprove(router, 0);
            IERC20(baseToken).safeApprove(router, uint(-1));
        }

        rewardToken = _rewardToken;

        IERC20(lpPair).safeApprove(masterchef, 0);
        IERC20(lpPair).safeApprove(masterchef, uint(-1));
        IERC20(rewardToken).safeApprove(router, 0);
        IERC20(rewardToken).safeApprove(router, uint(-1));
    }

    

    /**
     * @dev Function that puts the funds to work.
     * It gets called whenever someone deposits in the strategy's vault contract.
     * It deposits {lpPair} in the MasterChef to farm {wex}
     */
    function deposit() public {
        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));

        if (pairBal > 0) {
            depositToFarm(pairBal);
        }
    }
    
    /**
     * @dev Withdraws funds and sents them back to the vault.
     * It withdraws {lpPair} from the MasterChef.
     * The available {lpPair} minus fees is returned to the vault.
     */
    function withdraw(uint256 _amount) external onlyVault {

        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));

        if (pairBal < _amount) {   
            withdrawFromFarm(_amount.sub(pairBal));
            pairBal = IERC20(lpPair).balanceOf(address(this));
            IERC20(lpPair).safeTransfer(vault, pairBal);
        } else {
            IERC20(lpPair).safeTransfer(vault, _amount);
        }
    }
    
    
    function addliquidity() internal{
        uint amount = IERC20(rewardToken).balanceOf(address(this));

        uint amtToSell = amount.div(2);

        if (baseToken != rewardToken){     
            address[] memory path = ISwapPathRegistry(swapPathRegistry).getSwapRoute(router, rewardToken, baseToken);
            require(path.length > 0, "check swapPathRegistry1");
            KCSRouter2(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amtToSell, 0, path, address(this), now);
        }

        if (otherToken != rewardToken){
            address[] memory path2 = ISwapPathRegistry(swapPathRegistry).getSwapRoute(router, rewardToken, otherToken);
            require(path2.length > 0, "check swapPathRegistry2");
            KCSRouter2(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amtToSell, 0, path2, address(this), now);
        }

        KCSRouter2(router).addLiquidity(otherToken, baseToken, IERC20(otherToken).balanceOf(address(this)), IERC20(baseToken).balanceOf(address(this)), 0, 0, address(this), now);
    }
    function swapToStakingToken() internal{
        if (rewardToken != lpPair){
            uint amount = IERC20(rewardToken).balanceOf(address(this));
            address[] memory path = ISwapPathRegistry(swapPathRegistry).getSwapRoute(router, rewardToken, lpPair);
            require(path.length > 0, "check swapPathRegistry3");
            KCSRouter2(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), now);
        }
    }

    /**
     * @dev Core function of the strat, in charge of collecting and re-investing rewards.
     * 1. It claims rewards from the MasterChef.
     * 2. It charges the system fees to simplify the split.
     * 3. It swaps the {wex} token for {lpToken0} & {lpToken1}
     * 4. Adds more liquidity to the pool.
     * 5. It deposits the new LP tokens.
     */
    function harvest() external onlyNonContract{
        _harvest();
    }

    function harvestFromVault() external onlyVault {
        _harvest();
    }

    function _harvest() internal whenNotPaused {
        uint256 preBal = balanceOfPool();
        claim();

        if (IERC20(rewardToken).balanceOf(address(this)) > MIN_TO_LIQUIFY){
            chargeFees();
            if (baseToken != address(0)){
                addliquidity();
            } else {
                swapToStakingToken();
            }
            deposit();
        }

        uint256 postBal = balanceOfPool();
        if (postBal > preBal){
            emit Compound(msg.sender, postBal.sub(preBal));
        } else if (postBal < preBal){
            emit CompoundLoss(msg.sender, preBal.sub(postBal));
        }
        try IVault(vault).updatePricePerShare() {
        } catch(bytes memory reason){}

    }

    function getBPSFee() public view returns (uint) {
        uint256 fee = Buybackstrat(buybackstrat).performanceFeeBps();
        if (fee > FEE_CAP) {
            fee = FEE_CAP;
        }
        return fee;
    }

    function chargeFees() internal {
        if(buybackstrat!=address(0)){
            uint toSell = IERC20(rewardToken).balanceOf(address(this)).mul(getBPSFee()).div(10000);
            IERC20(rewardToken).transfer(buybackstrat, toSell);
        }
    }

    /**
     * @dev Function to calculate the total underlaying {lpPair} held by the strat.
     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.
     */
    function balanceOf() public view returns (uint256) {
        return balanceOfLpPair().add(balanceOfPool());
    }
    
    /**
     * @dev It calculates how much {lpPair} the contract holds.
     */
    function balanceOfLpPair() public view returns (uint256) {
        return IERC20(lpPair).balanceOf(address(this));
    }

    /**
     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef
     */
    function balanceOfPool() public view returns (uint256) {
        return IMasterChefWStakingReferral(masterchef).balanceOf(address(this));
    }

    /**
     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the 
     * vault, ready to be migrated to the new strat.
     */ 
    function retireStrat() external onlyOwner {
        panic();

        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));
        IERC20(lpPair).transfer(vault, pairBal);
    }

    /**
     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind
     */
    function panic() public onlyOwner {
        pause();
        withdrawFromFarm(balanceOfPool());
    }

    /**
     * @dev Pauses the strat.
     */
    function pause() public onlyOwner {
        _pause();
        IERC20(lpPair).safeApprove(masterchef, 0);
        IERC20(rewardToken).safeApprove(router, 0);
        if (baseToken != address(0)){
            IERC20(otherToken).safeApprove(router, 0);
            IERC20(baseToken).safeApprove(router, 0);
        }
    }

    /**
     * @dev Unpauses the strat.
     */
    function unpause() external onlyOwner {
        _unpause();

        IERC20(lpPair).safeApprove(masterchef, 0);
        IERC20(lpPair).safeApprove(masterchef, uint(-1));
        IERC20(rewardToken).safeApprove(router, 0);
        IERC20(rewardToken).safeApprove(router, uint(-1));
        if (baseToken != address(0)){
            IERC20(otherToken).safeApprove(router, 0);
            IERC20(otherToken).safeApprove(router, uint(-1));
            IERC20(baseToken).safeApprove(router, 0);
            IERC20(baseToken).safeApprove(router, uint(-1));
        }
    }
}