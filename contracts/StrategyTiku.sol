pragma solidity ^0.6.0;

import "./ISwapPathRegistry.sol";
import "./IPanwexPair.sol";
import "./KCSRouter2.sol";
import "./Buybackstrat.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

interface ITikuToken is IERC20{
    
    function claim() external;
    function getAccountDividendsInfo(address a)
        external view returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256);

}
interface WKCS is IERC20 {
    function deposit() external payable;
}
/**
 * @dev Implementation of a strategy to get yields from farming LP Pools in PanwexSwap.
 * PanwexSwap is an automated market maker (“AMM”) that allows two tokens to be exchanged on the Binance Smart Chain.
 * It is fast, cheap, and allows anyone to participate. PanwexSwap is aiming to be the #1 liquidity provider on BSC.
 *
 * This strategy simply deposits whatever funds it receives from the vault into the selected MasterChef pool.
 * CAKE rewards from providing liquidity are farmed every few minutes, sold and split 50/50. 
 * The corresponding pair of assets are bought and more liquidity is added to the MasterChef pool.
 * 
 * This strat is currently compatible with all LP pools.
 */
contract StrategyTiku is Ownable, Pausable {
    using SafeERC20 for ITikuToken;
    using SafeERC20 for WKCS;
    using Address for address;
    using SafeMath for uint256;

    /**
     * @dev Tokens Used:
     * {wkcs} - Required for liquidity routing when doing swaps.
     * {wex} - Token generated by staking our funds. In this case it's the CAKEs token.
     * {eleven} - ElevenFinance token, used to send funds to the treasury.
     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.
     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IPanwexPair tokens
     */
    modifier onlyOwnerOrVault() {
        require(owner() == _msgSender() || vault == _msgSender() , "Ownable: caller is not the owner/vault");
        _;
    }
    
    modifier onlyVault() {
        require(vault == _msgSender() , "Ownable: caller is not the vault");
        _;
    }

    
    function getPendingRewards() external view returns (uint256 pending){
        (,,,pending,,,,) = tiku.getAccountDividendsInfo(address(this));
    }

    WKCS public wkcs = WKCS(0x4446Fc4eb47f2f6586f9fAAb68B3498F86C07521);
    // these cant be changed after constructor
    ITikuToken public tiku;
    address public router;
    address public vault;

    // these can be changed after constructor, by the vault
    address public buybackstrat;
    address public swapPathRegistry;
    uint256 public MIN_TO_LIQUIFY = 1; // min amt of kcs to liquify


    event Deposit(address indexed account, uint256 amt);
    event Withdraw(address indexed account, uint256 amt);
    event Compound(address indexed caller, uint256 lpAdded);
    event CompoundLoss(address indexed caller, uint256 change); // shouldnt happen since im comparing balanceOfPool
    

    function setBuybackStrat(address _address) external onlyOwner{
        buybackstrat = _address;
    }
    function setSwapPathRegistry(address _a) external onlyOwner{
    swapPathRegistry = _a;
    }
    function setMinToLiquify(uint256 n) external onlyOwner{
        MIN_TO_LIQUIFY = n;
    }
    
    function deposit() public {
        
    }
    
    function withdraw(uint256 _amount) external onlyVault {

        uint256 pairBal = tiku.balanceOf(address(this));

        if (pairBal < _amount) {   
            tiku.safeTransfer(vault, pairBal);
        } else {
            tiku.safeTransfer(vault, _amount);
        }
    }
    
    constructor(address _tiku, 
        address _vault, 
        address _router, 
        address _swapPathRegistry, 
        address _feeStrat) public {

        tiku = ITikuToken(_tiku);
        swapPathRegistry = _swapPathRegistry;
        buybackstrat = _feeStrat;
        router = _router;
        vault = _vault;

        tiku.safeApprove(router, 0);
        tiku.safeApprove(router, uint(-1));

        wkcs.safeApprove(router, 0);
        wkcs.safeApprove(router, uint(-1));
    }
    
    receive() external payable {
  	}

    function swapToStakingToken() internal{
        // swap kcs to tiku
        uint amount = wkcs.balanceOf(address(this));
        address[] memory path = ISwapPathRegistry(swapPathRegistry).getSwapRoute(router, address(wkcs), address(tiku));
        require(path.length > 0, "check swapPathRegistry3");
        KCSRouter2(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), now);
    }

    function harvest() external {
        require(!Address.isContract(msg.sender), "!contract");
        _harvest();
    }

    function harvestFromVault() external onlyVault {
        _harvest();
    }

    function _harvest() internal whenNotPaused {

        uint256 preBal = balanceOf();
        tiku.claim();
        wkcs.deposit{value: address(this).balance}();

        if (wkcs.balanceOf(address(this)) > MIN_TO_LIQUIFY){
            chargeFees();
            swapToStakingToken();
        }

        uint256 postBal = balanceOf();
        if (postBal > preBal){
            emit Compound(msg.sender, postBal.sub(preBal));
        } else if (postBal < preBal){
            emit CompoundLoss(msg.sender, preBal.sub(postBal));
        }

    }

    function getBPSFee() public view returns (uint) {
        return Buybackstrat(buybackstrat).performanceFeeBps();
    }

    function chargeFees() internal {
        if(buybackstrat!=address(0)){
            uint toSell = wkcs.balanceOf(address(this)).mul(getBPSFee()).div(10000);
            wkcs.transfer(buybackstrat, toSell);
        }
    }

    /**
     * @dev Function to calculate the total underlaying {lpPair} held by the strat.
     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.
     */
    function balanceOf() public view returns (uint256) {
        return balanceOfLpPair().add(balanceOfPool());
    }
    
    /**
     * @dev It calculates how much {lpPair} the contract holds.
     */
    function balanceOfLpPair() public view returns (uint256) {
        return tiku.balanceOf(address(this));
    }

    /**
     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef
     */
    function balanceOfPool() public pure returns (uint256) {
        return 0;
    }

    /**
     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the 
     * vault, ready to be migrated to the new strat.
     */ 
    function retireStrat() external onlyOwner {
        panic();

        uint256 pairBal = tiku.balanceOf(address(this));
        tiku.transfer(vault, pairBal);
    }

    /**
     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind
     */
    function panic() public onlyOwner {
        pause();
    }

    /**
     * @dev Pauses the strat.
     */
    function pause() public onlyOwner {
        _pause();
    }

    /**
     * @dev Unpauses the strat.
     */
    function unpause() external onlyOwner {
        _unpause();
    }
}