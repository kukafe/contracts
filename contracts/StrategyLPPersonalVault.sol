pragma solidity ^0.6.0;

import "./ISwapPathRegistry.sol";
import "./IPanwexPair.sol";
import "./KCSRouter2.sol";
import "./Buybackstrat.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";


interface IMasterChefwStakingLockupReferrer {
    
    function deposit(uint256 poolId, uint256 amount) external;
    function withdraw(uint256 poolId, uint256 amount) external;

    function enterStaking(uint256 _amount) external;
    function leaveStaking(uint256 _amount) external;

    function deposit(uint256 poolId, uint256 amount, address referrer) external;
    
    // for lockup type of masterchefs
    function userInfo(uint256 poolId, address user) external view returns (uint256, uint256, uint256, uint256);

    function canHarvest(uint256 _pid, address _user) external view returns (bool);
}
/**
 * @dev Implementation of a strategy to get yields from farming LP Pools in PanwexSwap.
 * PanwexSwap is an automated market maker (“AMM”) that allows two tokens to be exchanged on the Binance Smart Chain.
 * It is fast, cheap, and allows anyone to participate. PanwexSwap is aiming to be the #1 liquidity provider on BSC.
 *
 * This strategy simply deposits whatever funds it receives from the vault into the selected MasterChef pool.
 * CAKE rewards from providing liquidity are farmed every few minutes, sold and split 50/50. 
 * The corresponding pair of assets are bought and more liquidity is added to the MasterChef pool.
 * 
 * This strat is currently compatible with all LP pools.
 */
contract StrategyLPPersonalVault is Ownable, Pausable {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    /**
     * @dev Tokens Used:
     * {wkcs} - Required for liquidity routing when doing swaps.
     * {wex} - Token generated by staking our funds. In this case it's the CAKEs token.
     * {eleven} - ElevenFinance token, used to send funds to the treasury.
     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.
     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IPanwexPair tokens
     */
    // modifier onlyOwnerOrUser() {
    //     require(owner() == _msgSender() || user == _msgSender() , "Ownable: caller is not the owner/user");
    //     _;
    // }
    modifier onlyUser() {
        require(user == _msgSender() , "Ownable: caller is not the user");
        _;
    }
    modifier onlyOperatorOrUser(){
        require(_msgSender() == operator || _msgSender() == user, "only operator or user");
        _;
    }
    // modifier onlyVault() {
    //     require(vault == _msgSender() , "Ownable: caller is not the vault");
    //     _;
    // }

    address public lpPair;

    address public rewardToken;
    address public otherToken;
    address public baseToken;

    address public router;
    
    address public masterchef;
    uint256 public poolId;

    
    address public buybackstrat;
    address public swapPathRegistry;
    uint256 public MIN_TO_LIQUIFY = 100; // just not zero.
    bool public stakingMode = false;
    bool public referralMode = false;

    // special stuff for private vault
    address public user;
    bool public exitMode;
    uint256 public amtManualDeposited;

    bool public CHECK_BY_ORIGIN = true; 
    uint256 public constant FEE_CAP = 30 * 100; // max fee possible 30%
    address public operator;

    event SetBuybackStrat(address a);
    event SetStakingMode(bool b);
    event SetReferralMode(bool b);
    event SetSwapPathRegistry(address a);
    event SetMinToLiquify(uint256 n);
    event SetExitMode(bool b);
    event SetCheckByOrigin(bool b);
    
    
    modifier onlyNonContract(){
        if (CHECK_BY_ORIGIN){
            // require(!Address.isContract(tx.origin), "!contract");
            require(tx.origin == msg.sender, "!contract!");
        }else{
            require(!Address.isContract(msg.sender), "!contract");
        }
        _;
    }
    function setCheckByOrigin(bool b) external onlyOwner {
        CHECK_BY_ORIGIN = b;
        emit SetCheckByOrigin(b);
    }
    function getFarmIdentifier() external view returns (bytes32){
        return keccak256(abi.encode(lpPair, rewardToken, baseToken, router, masterchef, poolId));
    }   
    function setBuybackStrat(address _address) external onlyOwner{
        buybackstrat = _address;
        emit SetBuybackStrat(_address);
    }
    function setStakingMode(bool _b) external onlyOwner{
        stakingMode = _b;
        emit SetStakingMode(_b);
    }
    function setReferralMode(bool _b) external onlyOwner{
        referralMode = _b;
        emit SetReferralMode(_b);
    }
    function setSwapPathRegistry(address _a) external onlyOwner{
        require(_a != address(0), "no zero address!");
        swapPathRegistry = _a;
        emit SetSwapPathRegistry(_a);
    }
    function setMinToLiquify(uint256 n) external onlyOwner{
        MIN_TO_LIQUIFY = n;
        emit SetMinToLiquify(n);
    }
    function depositToFarm(uint256 amt) internal{
        if (stakingMode){
            IMasterChefwStakingLockupReferrer(masterchef).enterStaking(amt);
        } else if (referralMode){
            IMasterChefwStakingLockupReferrer(masterchef).deposit(poolId,amt, address(0));
        } else {
            IMasterChefwStakingLockupReferrer(masterchef).deposit(poolId,amt);
        }
    }
    function withdrawFromFarm(uint256 amt) internal {
        if (stakingMode){
            IMasterChefwStakingLockupReferrer(masterchef).leaveStaking(amt);
        } else {
            IMasterChefwStakingLockupReferrer(masterchef).withdraw(poolId,amt);
        }
    }
    event Deposit(uint256 amount);
    event Withdraw(uint256 amount);
    /**
     * @dev Initializes the strategy with the token to maximize.
     */
    constructor(address _lpPair, 
    address _rewardToken, 
    address _baseToken, 
    address _masterchef, 
    uint256 _poolId, address _router, address _swapPathRegistry, address _user, address _feeStrat) public {
        lpPair = _lpPair;
        masterchef = _masterchef;
        poolId = _poolId;
        router = _router;
        swapPathRegistry = _swapPathRegistry;
        buybackstrat = _feeStrat;
        
        user = _user;

        if (_baseToken == address(0)){
            // token mode
            otherToken = address(0);
            baseToken = address(0);
        } else {
            address token0 = IPanwexPair(_lpPair).token0();
            address token1 = IPanwexPair(_lpPair).token1();
            (otherToken, baseToken) = (token0 == _baseToken) ? (token1,token0) : (token0,token1);
            IERC20(otherToken).safeApprove(router, 0);
            IERC20(otherToken).safeApprove(router, uint(-1));
            IERC20(baseToken).safeApprove(router, 0);
            IERC20(baseToken).safeApprove(router, uint(-1));
        }

        rewardToken = _rewardToken;

        IERC20(lpPair).safeApprove(masterchef, 0);
        IERC20(lpPair).safeApprove(masterchef, uint(-1));
        IERC20(rewardToken).safeApprove(router, 0);
        IERC20(rewardToken).safeApprove(router, uint(-1));
    }

    function setExitMode(bool _exit) public onlyUser{
        exitMode = _exit;
        emit SetExitMode(_exit);
    }

    function getRewardState() public view returns (uint256 amount, uint256 rewardLockedUp, uint256 nextHarvest) {
        (amount,,rewardLockedUp,nextHarvest) = IMasterChefwStakingLockupReferrer(masterchef).userInfo(poolId, address(this));
    }

    /**
     * @dev Function that puts the funds to work.
     * It gets called whenever someone deposits in the strategy's vault contract.
     * It deposits {lpPair} in the MasterChef to farm {wex}
     */
    function deposit() public{
        require(!exitMode, "In exit mode!");
        // resets the harvest lock!

        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));
        if (pairBal > 0) {
            depositToFarm(pairBal);
             _harvest(false);
            emit Deposit(pairBal);
        }
    }

    function userDeposit(uint256 _amount) external onlyUser{
        IERC20(lpPair).safeTransferFrom(msg.sender, address(this), _amount);
        amtManualDeposited = amtManualDeposited.add(_amount);
        deposit();
    }   
    
    // exit instructions => withdrawal, then wait for at least 1h for remaining reward to be sent to your acc


    /**
     * @dev Withdraws funds and sents them back to the vault.
     * It withdraws {lpPair} from the MasterChef.
     * The available {lpPair} minus fees is returned to the vault.
     */
    function withdraw(uint256 _amount) external onlyUser{
        
        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));

        if (pairBal < _amount) {   
            withdrawFromFarm(_amount.sub(pairBal));
            pairBal = IERC20(lpPair).balanceOf(address(this));
            IERC20(lpPair).safeTransfer(user, pairBal);
            if (pairBal <= amtManualDeposited){
                amtManualDeposited = amtManualDeposited.sub(pairBal);
            } else {
                amtManualDeposited = 0;
            }
            if (!exitMode){
                _harvest(false);
            }

        } else {
            IERC20(lpPair).safeTransfer(user, _amount);
            if (_amount <= amtManualDeposited){
                amtManualDeposited = amtManualDeposited.sub(_amount);
            } else {
                amtManualDeposited = 0;
            }
            if (!exitMode){
                _harvest(true);
            }
        }
        if (exitMode){
            uint256 rewardBal = IERC20(rewardToken).balanceOf(address(this));
            IERC20(rewardToken).safeTransfer(user, rewardBal);
        }
        if (balanceOfPool() == 0){
            amtManualDeposited = 0;
        }
    }
    function exit() external onlyUser{
        _exit();
        exitMode = true;
    }

    function _exit() internal {
        withdrawFromFarm(balanceOfPool());
        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));
        IERC20(lpPair).safeTransfer(user, pairBal);

        uint256 rewardBal = IERC20(rewardToken).balanceOf(address(this));
        IERC20(rewardToken).safeTransfer(user, rewardBal);
        
        if (balanceOfPool() == 0){
            amtManualDeposited = 0;
        }

    }
    
    
    function addliquidity() internal{
        uint amount = IERC20(rewardToken).balanceOf(address(this));
        uint amtToSell = amount.div(2);

        if (baseToken != rewardToken){     
            address[] memory path = ISwapPathRegistry(swapPathRegistry).getSwapRoute(router, rewardToken, baseToken );
            require(path.length > 0, "check swapPathRegistry1");
            KCSRouter2(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amtToSell, 0, path, address(this), now);
        }

        if (otherToken != rewardToken){
            address[] memory path2 = ISwapPathRegistry(swapPathRegistry).getSwapRoute(router, rewardToken, otherToken );
            require(path2.length > 0, "check swapPathRegistry2");
            KCSRouter2(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amtToSell, 0, path2, address(this), now);
        }

        KCSRouter2(router).addLiquidity(otherToken, baseToken, IERC20(otherToken).balanceOf(address(this)), IERC20(baseToken).balanceOf(address(this)), 0, 0, address(this), now);
    }
    function swapToStakingToken() internal{
        if (rewardToken != lpPair){
            uint amount = IERC20(rewardToken).balanceOf(address(this));
            address[] memory path = ISwapPathRegistry(swapPathRegistry).getSwapRoute(router, rewardToken, lpPair);
            require(path.length > 0, "check swapPathRegistry3");
            KCSRouter2(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), now);
        }
    }


    /**
     * @dev Core function of the strat, in charge of collecting and re-investing rewards.
     * 1. It claims rewards from the MasterChef.
     * 2. It charges the system fees to simplify the split.
     * 3. It swaps the {wex} token for {lpToken0} & {lpToken1}
     * 4. Adds more liquidity to the pool.
     * 5. It deposits the new LP tokens.
     */
    function harvest() external onlyNonContract{
        // require(!Address.isContract(msg.sender), "!contract");
        _harvest(true);
    }
    function exitHarvest() external onlyNonContract{
        // require(!Address.isContract(msg.sender), "!contract");
        require(exitMode, "not exitmode!");
        _exit();
    }
    function canExitHarvest() external view returns (bool) {
        // to check if bot should call exitHarvest function
        uint256 rewardBal = IERC20(rewardToken).balanceOf(address(this));
        (, uint256 rewardLockedUp,) = getRewardState();
        return 
            (IMasterChefwStakingLockupReferrer(masterchef).canHarvest(poolId, address(this)) && rewardLockedUp > 0) ||
            (balanceOfPool() > 0) || 
            (rewardBal > 0);

    }
    function _harvest(bool claimPendingRewards) internal whenNotPaused {

        if (exitMode){
            return;
        }
        if (claimPendingRewards && IMasterChefwStakingLockupReferrer(masterchef).canHarvest(poolId, address(this))){
            depositToFarm(0);
        }
        uint256 rewardTokenBal = IERC20(rewardToken).balanceOf(address(this));
        if (rewardTokenBal == 0 || rewardTokenBal < MIN_TO_LIQUIFY){
            return;
        }
        chargeFees();
        if (baseToken != address(0)){
            addliquidity();
        } else {
            swapToStakingToken();
        }
        uint256 bal = balanceOfLpPair();
        if (bal > 0){
            depositToFarm(bal);
        }
    }

    function getBPSFee() public view returns (uint) {
        uint256 fee = Buybackstrat(buybackstrat).performanceFeeBps();
        if (fee > FEE_CAP) {
            fee = FEE_CAP;
        }
        return fee;


    }

    function chargeFees() internal {
        if(buybackstrat!=address(0)){
            uint toSell = IERC20(rewardToken).balanceOf(address(this)).mul(getBPSFee()).div(10000);
            IERC20(rewardToken).transfer(buybackstrat, toSell);
        }
    }
    
    /**
     * @dev Function to calculate the total underlaying {lpPair} held by the strat.
     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.
     */
    function balanceOf() public view returns (uint256) {
        return balanceOfLpPair().add(balanceOfPool());
    }

    /**
     * @dev It calculates how much {lpPair} the contract holds.
     */
    function balanceOfLpPair() public view returns (uint256) {
        return IERC20(lpPair).balanceOf(address(this));
    }

    /**
     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef
     */
    function balanceOfPool() public view returns (uint256) {
        (uint256 _amount,,,) = IMasterChefwStakingLockupReferrer(masterchef).userInfo(poolId, address(this));
        return _amount;
    }

    /**
     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind
     */
    function panic() public onlyOperatorOrUser {
        pause();
        withdrawFromFarm(balanceOfPool());
        if (balanceOfPool() == 0){
            amtManualDeposited = 0;
        }
    }

    function saveToken(address _token) external {
        require(msg.sender == user, "only user!");
        IERC20 token = IERC20(_token);
        uint256 tokenBalance = token.balanceOf(address(this));
        token.transfer(msg.sender, tokenBalance);
    }

    /**
     * @dev Pauses the strat.
     */
    function pause() public onlyOperatorOrUser {
        _pause();
        IERC20(lpPair).safeApprove(masterchef, 0);
        IERC20(rewardToken).safeApprove(router, 0);
        if (baseToken != address(0)){
            IERC20(otherToken).safeApprove(router, 0);
            IERC20(baseToken).safeApprove(router, 0);
        }
    }

    /**
     * @dev Unpauses the strat.
     */
    function unpause() external onlyOperatorOrUser {
        _unpause();

        IERC20(lpPair).safeApprove(masterchef, 0);
        IERC20(lpPair).safeApprove(masterchef, uint(-1));
        IERC20(rewardToken).safeApprove(router, 0);
        IERC20(rewardToken).safeApprove(router, uint(-1));
        if (baseToken != address(0)){
            IERC20(otherToken).safeApprove(router, 0);
            IERC20(otherToken).safeApprove(router, uint(-1));
            IERC20(baseToken).safeApprove(router, 0);
            IERC20(baseToken).safeApprove(router, uint(-1));
        }
    }
}